// -*-c++-*-
// vim: set ft=cpp:

/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
   file Copyright.txt or https://cmake.org/licensing for details.  */
#ifndef cm_iterator
#define cm_iterator

#include <iterator> // IWYU pragma: export

namespace cm {

#if __cplusplus >= 201402L || defined(_MSVC_LANG) && _MSVC_LANG >= 201402L
using std::make_reverse_iterator;

using std::cbegin;
using std::cend;
#else
template <class Iter>
std::reverse_iterator<Iter> make_reverse_iterator(Iter it)
{
  return std::reverse_iterator<Iter>(it);
}

// std::c{begin,end} backport from C++14
template <class C>
#  if defined(_MSC_VER) && _MSC_VER < 1900
auto cbegin(C const& c)
#  else
constexpr auto cbegin(C const& c) noexcept(noexcept(std::begin(c)))
#  endif
  -> decltype(std::begin(c))
{
  return std::begin(c);
}

template <class C>
#  if defined(_MSC_VER) && _MSC_VER < 1900
auto cend(C const& c)
#  else
constexpr auto cend(C const& c) noexcept(noexcept(std::end(c)))
#  endif
  -> decltype(std::end(c))
{
  return std::end(c);
}
#endif

#if __cplusplus >= 201703L || defined(_MSVC_LANG) && _MSVC_LANG >= 201703L
using std::size;
#else

// std::size backport from C++17.
template <class C>
#  if !defined(_MSC_VER) || _MSC_VER >= 1900
constexpr
#  endif
  auto
  size(C const& c) -> decltype(c.size())
{
  return c.size();
}

template <typename T, size_t N>
#  if !defined(_MSC_VER) || _MSC_VER >= 1900
constexpr
#  endif
  std::size_t
  size(const T (&)[N]) throw()
{
  return N;
}

#endif

} // namespace cm

#endif
